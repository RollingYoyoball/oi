也是一道很好玩的题
据说是clj大佬自己出的orz然后就卡了一小会。。

正常建一个s的后缀自动机，然后统计每个节点的出现次数，方法跟fail树上面的是一样的
注意不能边建自动机边加，因为这样不能保证复杂度是线性的

然后到了统计
看到这种奇怪的转转不已的题目，首先一个非常简单粗暴的想法就是倍长一发
然后发现如果。。暴力每种情况都匹配一次显然会超时
然后就想到可以利用已经匹配了的位置

会注意到suffix数组存下来的东西是当前的一个后缀，所以如果当前的是匹配的，它的suffix也一定是可以的
所以如果说匹配的长度大于lens的话，就一直跳suffix直到最小的len[now]>=len然后累加答案即可
注意：不一定能跳到len[now]==len，因此只要找到最小的比len大的就行了，次数是共享的所以可以直接加,而如果再往前跳的话len[now]
就会比len要小了，所以可以保证直接加cnt不会算重复


最后要注意一个东西就是要判重，如果同一个字符串被匹配到了两次显然是不行的，所以要加一个标记简单标记一下即可
