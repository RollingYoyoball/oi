Portal --> broken qwq

### Description

​	大M成立的怪兽电力公司最近刚建立了一个网站。这个季度共有$n$天，第$i$天共有$v[i]$个用户点击该网站，总的广告价值为$c[i]$。     然而大M并不知道该如何计算收入。他定义某一天的收入$p[i]=min(100*max(v[i..j]),min(c[i..j]))（j>=i)$。也许$j$不同会导致$p[i]$不同，大M会选择一个$j$使得$p[i]$最大。     

​	大M并不知道该如何算这个季度的每天平均收入。他会随机在$n$天中选择$k$天$i_1,i_2...i_k$，则这个季度的每天平均收入就定为$min(p[i_1],p[i_2]...p[i_k])$。     你作为他的会计对于他这种计算方法十分不放心。你想要知道在大M的计算下，这个季度的每天平均收入的期望值。 

​	数据范围：对于100%的数据，$n<=300000,k<=n,v[i]<=10^7,c[i]<=10^9$ 



### Solution

​	首先我们假设我们已经求出了$p$，那么接下来的答案要怎么算?

​	看到这种最大最小值贡献类的题目。。感觉都有一个比较好的方向就是可以从某一个数作为最值然后反过来计算其贡献

​	比如说在这题里面就是，考虑每一个$p[i]$会在多少中选择中有贡献，具体一点就是我们考虑将$p$按照从小到大的顺序排列，然后依次从左往右考虑每一个$p[i]$的贡献

​	对于第$i$个位置的$p$值，因为这个位置要作为最小值才能有贡献，所以$i$前面的数全部都不能选，所以也就是$\binom {n-i} {k-1}$种组合（第$i$这个位置的数确定要选，然后剩下的$k-1$个数只能在后面的$n-i$个数里面选），算概率的话就是除以一个总的方案数也就是$\binom n k$即可

​	那么现在的问题是，直接求组合数是不行的（没有模数）

​	注意到每一个位置乘的系数那个组合数都是$\binom x {k-1}/\binom n k​$的形式，然后当$x=n-1​$的时候这个式子是$=k/n​$的，然后我们发现对于不同的$i​$，在改变的只有$x​$，那我们把这个式子用阶乘的形式写开就发现它可以非常愉快地一路递推回去了（每次$*(n-i-k+1)/(n-i)​$就可以了）

​	

​	然后现在的问题就只剩下怎么求$p$了

​	我们观察一下$p[i]$的表达式，前半部分是取$max$（不递减），后半部分是取$min$（不递增），总的又是取$min$，稍微画一下函数图像之类的就可以发现能更新当前位置的方案一定是前面的$p$值或者令题目中的那个$j$等于当前位置时候表达式的取值

​	所以我们可以直接$O(n)$dp一下得到$p$

​	然后这题就做完啦ovo



​	代码大概长这个样子

```C++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=300010;
int v[N],c[N],p[N];
long double ans,C;
int n,k;

int main(){
#ifndef ONLINE_JUDGE
	freopen("a.in","r",stdin);
#endif
	scanf("%d%d",&n,&k);
	for (int i=1;i<=n;++i) scanf("%d",v+i);
	for (int i=1;i<=n;++i) scanf("%d",c+i);
	p[n]=min(v[n]*100,c[n]);
	for (int i=n-1;i>=1;--i){
		p[i]=max(p[i+1],100*v[i]);
		p[i]=min(p[i],c[i]);
	}
	sort(p+1,p+1+n);
	ans=0; C=(1.0*k)/(1.0*n);
	for (int i=1;n-i>=k-1;++i){
		ans+=1.0*p[i]*C;
		C*=(1.0*n-i-k+1)/(1.0*n-i);
	}
	printf("%.10Lf\n",ans);
}
```

