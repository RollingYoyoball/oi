f[i][j]表示前i位的长度为j的后缀与不吉利数字匹配
转移的时候，避免出现不合法的情况，所以只转移0~m-1，这样就可以保证枚举到所有不匹配的结果
那么ans=f[n][0]+f[n][1]+...+f[n][m-1]

现在考虑f的转移
先定义一个数组a，a[i][j]表示当前准考证的末尾i位已经和不吉利数字匹配的情况下，添加一个数字后，这个有i+1位的准考证号末尾
最多有j位与不吉利数字匹配，的满足的数字的个数

那么，f[i][j]=f[i-1][0]*a[0][j]+f[i-1][1]*a[1][j]+f[i-1][2]*a[2][j]+...+f[i-1][m-1]*a[m-1][j];

初始化的话，显然f[0][0]=1;

然后就会发现神奇的事情
这个递推式的形式就是矩阵乘法，然后系数是不变的
所以可以用矩阵快速幂来加速

关于a怎么求
对于每一位，可以暴力枚举一下下一位填什么，然后用kmp跑一遍，与前面的匹配，这样长度不会超过i，所以就可以避免重复
记跑出来的答案是ans，如果可以匹配到的话，a[i][ans]++,否则a[i][0]++;
