哇塞这题写的真是爽到我了。。

嗯。。可能是写过。。最长的代码之一？（另一道写了很长很长的是点分吧好像）

首先，要搞最小生成树，然后看范围什么的十分不友善显然应该是先把原来的树搞出来然后再搞事情
那么接下来就是看删掉一个点有什么影响了
记原来就在最小生成树里面的边为树边，其他为非树边
与点x相连的树边的权值和记为sum[x]
最初步的想法是，将原来的最小生成树的边权和记为sum1，删掉一个点后的ans应该就是sum1-sum[x]+要添加上的边

好了，那么现在问题变成求添加上的边权和

画一下图可以发现，一个点被删掉之后，将原树分为若干个连通块
这些连通块其实可以分成两类：
1.位于x下方的，也就是以x的后继为根的若干个子树
2.位于x上方的一个
现在要做的事情就是将添加后可能重新变成最小生成树的边列出来然后跑一遍最小生成树就好了

能添加的边有两类：
1.添加后可以连通位于x下方的两个连通块，不妨记这种边为横边
2.添加后可以连通位于x下方的一块和x上方的一整块，记这种边为纵边

显然，想要在时间复杂度允许的情况下解决这些问题，应该要先预处理出删掉每个点之后能添加的边有哪些，然后直接枚举每一个点跑

所以考虑预处理
首先是横边：
考虑一条边（u，v），这条边可以为横边，当且仅当lca(u,v)是被删掉的那个点（否则这条边没有连的意义），
同时还要满足u和v不是被删掉的点，也就是u!=lca&&v!=lca
然后因为两个点有且仅有一个lca，所以每条边只会被考虑一次，只要枚举就好，复杂度为O(m）
实现的话可以用一个vector来存每一个x的横边

接着是纵边：
定义一个数组out，out[x]表示当x的父亲是被删掉的那个点的时候，x及其子树的纵边的最小值
如果能将out预处理出来的话，求解的时候只要直接将out对应的边加进去即可
考虑out怎么求
可以考虑一条边(u,v)，这条边可以为纵边，当且仅当被删掉的点是u到v路径上的一个点（否则两点属于同一个连通块）
那么对out的影响范围就缩小到u到v路径上的点的out值
再画一下图，就会发现，这条路径上只有三个点的out值不会被影响：lca,以及lca的两个儿子
lca不会被影响是显然的，因为当要考虑lca的out的时候，被删掉的点应该是fa[lca]，此时u和v位于同一连通块
lca的两个儿子不会被影响，因为此时被删掉的点是lca，(u,v)就应该是一条横边而不是纵边了

明确了这点之后，就发现对于(u,v)，要更新u到dep[lca]-2的点的out和v到dep[lca]-2的点的out
发现是对路径权值的修改
那就。。。
树剖啊哈哈哈哈哈线段树维护最小值区间修改打打标记愉快玩耍

考虑完这些问题之后，后面就是枚举每一个被删掉的边然后把可以添加的边丢到一个数组里面去排个序然后跑一发
然后就愉快地解决啦ovo