#### 问题描述

​	快速求**素数处点值比较好求**的**积性函数**前缀和



#### 大致过程

​	Step1、求出一定范围内的素数处点值之和（$g$）

​	Step2、利用上面的$g$求出一个$f$然后用$f$求出前缀和



#### 具体过程

​	（这里约定一下，在下面的内容中用$p$表示一个素数，用$P_i$表示素数列表中的第$i$项）

​	这里以求$\sum \phi(i)$为例

​	首先对于素数$p$来说，$\phi(p)=p-1$的，因此我们可以快速求出素数处点值的和$\sum \phi(p)=\sum p - \sum 1$

​	这个时候我们定义
$$
\begin{aligned}
g_{i,j}&=\sum\limits_{k=2}^{i}[k与P_1、P_2、P_3...P_j互质或者就是其中的某个素数]k\\
&=\sum\limits_{k=2}^{i}[k是P_j的素数\ 或\ k的最小质因子>P_j]\\
\end{aligned}
$$
​	初始化$g_{i,0}=\sum\limits_{k=2}^{i} k​$

​	有了这个东西的话我们就可以比较快速的知道某一个范围内的素数处点值的函数值和了

​	现在考虑$g_{i,j}$怎么求，我们考虑从$g_{i,j-1}$推到$g_{i,j}$

​	（这里的大体思想其实和。。之前在[博客里面写到的某道题pxp](https://www.cnblogs.com/yoyoball/p/8780223.html)。。差不多，或者说pxp其实就是洲阁筛的前半部分）

​	

​	将具体的含义列出来，我们要做的就是从
$$
满足k<=P_{j-1}的素数\ 或\ k的最小质因子>P_{j-1}的k的和
$$
​	推到
$$
满足k<=P_j的素数\ 或\ k的最小质因子>P_j的k的和
$$
​	看一下我们要修改的部分，对于前半部分来说应该是加上一个$P_j$（如果在范围内的话），对于后半部分来说应该是减去一些数（不满足第二个条件），这些数满足
$$
x=P_j*（一个y满足最小质因子>P_j，并且范围在[P_j,\lfloor\frac{i}{P_j}\rfloor]的数）
$$
​	于是乎我们非常愉快地发现后面那个括号里面的那一堆东西的和可以用回$g$来容斥一下表示！
$$
\sum y=g_{\lfloor\frac{i}{P_j}\rfloor,j-1}-g_{P_j-1,j-1}
$$
​	然后我们就可以由$g_{i,j-1}​$推到$g_{i,j}​$啦
$$
g_{i,j}=g_{i,j-1}-P_j(g_{\lfloor\frac{i}{P_j}\rfloor,j-1}-g_{P_j-1,j-1})
$$
​	然而对于不同的积性函数来说，第一步的求法会有一定的差异，也许会有更加简单的求法，反正就是要求出一个函数能够快捷方便滴得到某一个范围内的素数处点值的和就好了



​	如果一定要写一个通式的话其实就是：
$$
g_{i,j}=g_{i,j-1}-F(P_j)(g_{\lfloor\frac{i}{P_j}\rfloor,j-1}-g_{P_j-1,j-1})
$$
​	其中满足$F$是一个**完全积性函数**（因为把$P_j$提出来那步需要用到完全积性函数的性质，你并不能保证后面的那堆东西一定和$P_j$互质）

​	然后$F$的话具体看最开始给的要求前缀和的函数在素数处的点值的表达式具体是啥而定，比如在这个例子里面就是$F(x)=x$

​	



​	接下来是用这个$g$来求$h$
$$
h_{i,j}=\sum\limits_{k=2}^{i}[k最小质因子>=P_j]\phi(k)
$$
​	（如果是别的函数的话就换一下后面的$\phi(k)$就可以了）

​	考虑这样一种枚举方式：

​	每一个数我们都可以拆成
$$
（最小质因子）^q*一些别的东西（可以是1）
$$
​	所以我们可以将上面的表达式通过枚举素数以及次方的方式写成这样：
$$
h_{i,j}=\sum_{q}\phi(P_j^q)\cdot h_{\lfloor \frac{i}{P_j^e}\rfloor,j+1}
$$
​	然后就可以推$h_{i,j}​$啦

​	然而。。。直接搞会比较麻烦。。因为这里为了保证复杂度还是需要上面提到的$i>=P_j^2$的优化，但是这里没有那么简单，而是需要打上标记

​	所以这里写上另一种方式（貌似是min_25筛来着）
$$
h_{i,j}=\sum_{P_k>=P_j}\sum_{q>=1,P_k^q<=i}\phi(P_k^q)\cdot(h_{\lfloor \frac{i}{P_k^q}\rfloor,j+1}+1)
$$
​	后面那里要$+1​$是因为要把$\phi(P_k^q)​$的部分也算上（否则都是$\phi(P_k^q*一些别的东西)​$)

​	然后直接大力搜索就可以了

​	边界条件：$i<=1$的时候返回$0$

​	有趣的是，并不需要记忆化ovo

​	因为可以说明$h$是不会被重复调用的%%%

​	然后最后的答案就是$h_{n,1}+\phi(1)$啦



#### 总的来说

​	额其实就是
$$
\begin{aligned}
g_{i,j}&=g_{i,j-1}-F(P_j)(g_{\lfloor\frac{i}{P_j}\rfloor,j-1}-g_{P_j-1,j-1})\\
\\
h_{i,j}&=\sum_{P_k>=P_j}\sum_{e>=1,P_k^e<=n}f(P_k^e)\cdot h_{\lfloor \frac{i}{P_k^e}\rfloor,j+1}
\end{aligned}
$$
​	然后$F$是**完全积性函数**，$f$是题目给的是一个积性函数，$F$是根据$f$在素数处点值的表达式构造的

​	大概是这样嗯ovo

​	哦然后时间复杂度是$O(\frac{n^{\frac{3}{4}}}{logn})$的至于证明的话。。不会qwq

​	虽然说思路真的巨无敌绕不过弄懂了的话还是比较好理解的ovo~~（假装这两句话一点都不矛盾）~~



#### 实现问题

​	关于实现的话有这样几个比较重要的点单独拿出来说一下



​	1.Step1中，关于$g_{i,j}$的求解：

​	题目中的$n$往往很大，$i$直接这么枚举的话直接就愉快爆炸了

​	这里我们可以发现一个性质，就是我们其实只用关注第一维的$i$满足$i \in \{\lfloor \frac{n}{x} \rfloor|x \in [1,n]\}$的$g_{i...}$值

​	我们将这个集合记为$S$，那么是有$|S|=2\sqrt n$的，在具体实现的时候，我们可以先离散化一下，需要调用的时候再映射回去就好了

​	为什么我们可以这么做呢？看回递推式中我们需要的$g$的第一维，前一部分是$\lfloor \frac{i}{P_j} \rfloor$，这是$\in S$的，后一部分是$P_j-1$，因为$P_j$我们限制是$< \sqrt n$的，所以$P_j-1\in S$，所以只有$i\in S$的$g_{i,...}$才是我们实际需要算的值	



​	2.Step2中，关于$h_{i,j}$的求解：

​	同样的，如果第一维直接枚举$n$的话简直炸成烟花

​	这里观察一下当$i<P_j$的情况，会发现当$i<P_j^2$的时候，能算进来的只有$>=P_j且<=i$的质数处的函数值，所以这一部分的和可以直接用$g_{i,max+1}-g_{P_j-1,max+1}$表示，其中$max$是素数列表的长度

​	所以枚举的时候只枚举到$P_j^2<=i$，然后最后判断一下如果存在$i<P_j^2$这种情况的话，就把后面整段的值一起加进返回值里，也就是直接加上$g_{i,max+1}-g_{P_j-1,max+1}$



#### 代码的话

​	看这题好了 [Portal -->【SPOJ】DIVCNTK](https://www.cnblogs.com/yoyoball/p/9193570.html)