考虑一个字符串（每个字母代表一段字符）
abcabc
假设a部分和c部分是匹配的，那么计算到第二个c部分时，a和c匹配，那么不考虑重叠的话，num应该是等于next的num+整个大的abc
也就是num=num[next]+1

然后在计算结果的时候只加合法的即可
由于计算的时候是从前往后的，所以每次只要一直跳next跳到第一个next<当前一半的长度即可，然后再把num加到ans里面去

注意：kmp的next存的是跳到的下标，然后s是从第0位开始的，所以要记得在判断的时候加上1