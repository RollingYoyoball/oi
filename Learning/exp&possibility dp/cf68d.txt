这题嘛。。十分的短呀
好的但是想起来的话qwq嗯。。

首先注意到一个很神秘的事情
因为这是棵二叉树，高度h<=30的，
我们假设已经知道了选择的是哪个叶子，那么可以在logn时间内求得答案
同理，修改权值的时候也是log的

那所以就有一个类似贪心的思想
开一个map来记录以x为根的子树下的权值和（叫sum好了）
修改就直接暴力往上跳然后加进去就ok了

然后查询的时候
从根节点开始遍历，记录一路上的最大值mx
每次比较sum[lch]和sum[rch]
如果说选中的点在较大的那边，那就肯定要递归处理了，这种情况的概率是1/2
否则就直接返回max（mx，sum（较大）），这种情况的概率也是1/2

一个小优化之类的？
如果说当前的sum已经小于mx，那么就没有继续往下搜的必要了，直接返回mx