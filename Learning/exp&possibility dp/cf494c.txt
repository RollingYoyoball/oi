这题的话。。嗯。。cf的题解看得懵懵的不过最后还是敲出来了。。喵啊qwq

首先注意到题目有一个很神秘的条件：
各个区间要么是完全包含关系（可以重合）要么不相交
这就很玄妙了

利用的话就是可以把给出来的区间变成一棵树
树上的每个节点代表一个区间
对于两个区间x和y，如果说x是最小的包含y的区间，那么x就是y的父亲
一开始先人为插入一个区间[1,n]，概率为0这样就不会影响结果同时也相当于给一个树根

建出来以后，就考虑怎么算ans
用mx[i]表示i这个节点对应的区间内的最大值（初始）
用f[i][j]表示的是i这个节点对应的区间内，最大值至多为mx[i]+j的概率
那么最后的ans可以表示为（mx0表示初始值中的最大值）
mx0*f[1][0]+sigma((f[1][i]-f[1][i-1])*(mx0+i))(1<=i<=q)
（至多只能加q个）

接下来就是f怎么求的问题了
对于一个点x，我们考虑它的一个儿子u
考虑求f[x][j]
如果说x这个区间不选
那么显然，我们要让x的子树下最大值至多为mx[x]+j，就必须要求u的子树下最大值至多为mx[x]+j
也就是说能够在mx[u]的基础上增加的数值最大为mx[x]-mx[u]+j
那么我们就能得到不选择x的概率的表达式为
npick=（1-p[x]）*（连乘qwq打不出来就是这样qwq）f[u][mx[x]-mx[u]+j]（u为x的儿子，且0<=mx[x]-mx[u]+j<=q）

如果说是x选的话其实是一样的
只是因为这个区间选所以会多1，所以就变成了f[u][mx[x]-mx[u]+j-1]，然后前面乘的概率变成了p[x]而已
（记为pick好了）

那么f[x][j]=npick+pick啦

关于初始化的话。。就是如果说x是一个叶子节点的话，那么只有f[x][0]=1-p[x]
然后剩下的全是1就好了

然后就。。做完啦ovo
